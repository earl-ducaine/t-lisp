(HERALD (TCOMP GENERATE T 255)
        (ENV TCOMP))

;;; Copyright (c) 1980, 1981 Lawrence Livermore Laboratories
;;; Modifications copyright (c) 1983, 1984 Yale University

;;;; Code generation

;;; This contains the skeleton of the code generator, with utilities.
;;; Everything in this file should be sharable from one implementation's
;;; code generator to the next.  These routines call and are called by
;;; the machine-specific routines.

;;; To do:
;;;   - Definee for return templates
;;;   - Template tags (or offsets) returned out of EMIT module instead of
;;;     generated here.

;;; Utilities

;;; Yield SOURCE as the value of NODE.  Passing a FALL-THROUGH? argument of
;;; NIL is always guaranteed to produce correct code, but may cause much
;;; unneeded jumping around.

(DEFINE (YIELD NODE SOURCE FALL-THROUGH?)
  (LET ((LEVEL (NODE-LEVEL NODE)))
    (LET ((NEWSOURCE (TN-MOVE-1 NODE
                                (NODE-WANTTN LEVEL)
                                (NODE-WANTREP LEVEL)
                                (NODE-ISREP NODE)
                                SOURCE
                                (NODE-ALIASP LEVEL))))
      (COND ((AND (LAMBDA-NODE? (NODE-PARENT LEVEL))
                  (NOT (MEMQ (LAMBDA-STRATEGY (NODE-FORM (NODE-PARENT LEVEL)))
                             '(JUMP NONE))))
             (GEN-IRETURN))
            (ELSE
             (ADJUST-STACK (NODE-STACKNUM LEVEL))
             (COND (FALL-THROUGH? NEWSOURCE)
                   (ELSE
                    (IF (EMPTY (NODE-GENTAG LEVEL))
                        (SETF (NODE-GENTAG LEVEL)
                              (GENTAG (STYPE (NODE-FORM LEVEL)))))
                    (UNCONDITIONAL-JUMP (NODE-GENTAG LEVEL)))))))))

(DEFINE (TN-MOVE DESTTN DESTREP SOURCEREP SOURCE ALIASP)
  (TN-MOVE-1 NIL DESTTN DESTREP SOURCEREP SOURCE ALIASP))

;;; Move the SOURCE operand to the destination required by the TN,
;;; performing type conversion if necessary.
;;; --- This is awful stuff.  It really wants to be rewritten somehow.

(DEFINE (TN-MOVE-1 NODE DESTTN DESTREP SOURCEREP SOURCE ALIASP)
  (COND ((EQ? SOURCE 'GONE)
         SOURCE)
        ((EQ? DESTREP 'NONE)
         '(BAD-OPERAND TN-MOVE))
        ((EQ? DESTREP SOURCEREP)
         (COND ((USE-ALIAS? SOURCE ALIASP)      ; See PRODUCE
                SOURCE)
               (ELSE (XMOVE SOURCE (TNLOC DESTTN) DESTREP (TN-SIZE DESTTN)))))
        ((EQ? SOURCEREP 'NONE)
         (BUGLET ((*DESTTN* DESTTN))
                 "SOURCEREP=NONE in TN-MOVE (SOURCE=~S, DESTREP=~S)"
                 "will not attempt to perform TN movement"
                 SOURCE DESTREP)
         '(BAD-OPERAND TN-MOVE))
        (ELSE
         (CONVERT-REP NODE SOURCEREP SOURCE DESTREP (TNLOC DESTTN) ALIASP))))

(DEFINE (XMOVE SOURCE DEST REP SIZE)
  (LET ((FN (GET REP 'MOVE)))
    (COND ((ALIKEV? SOURCE DEST) DEST)
          (FN (FN SOURCE DEST) DEST)
          ((NOT (FX= SIZE 1))
           (BUG "moving ~D pesos (REP = ~S) from ~S to ~S, but don't know how"
                "will not perform any motion, and just assume result got to ~S"
                SIZE REP SOURCE DEST DEST)
           DEST)
          (ELSE (MOVE SOURCE DEST)))))

;;; Predicate: returns true only if it's safe to generate an alias for
;;; NODE in lieu of pending generation of code for nodes in NODELIST.
;;; -- Could this be a little more lenient perhaps?
;;; -- Could it be more correct?!  Steele's original definition didn't work
;;; on cases like (LET ((X (+ Y 1))) (+ X (FOO X)))
;;; An optimal version of this would see if NODE's WANTLOC will be
;;; clobberred by the code to be generated by any of the nodes in NODELIST.
;;; This kind of stuff really needs to be done in TARGETIZE.

(DEFINE (ALIAS-IF-SAFE NODE NODELIST)
  (COND ((CONSTANT-NODE? NODE) T)
        ((OR (STATIC-NODE? NODE) (VARIABLE-NODE? NODE))
         (D0 ((N NODELIST (CDR N)))
             ((NULL? N) T)
           ----
           (OR (MEMQ (STYPE (CAR N)) '(CONSTANT STATIC VARIABLE))
               ; predicate was (PASSABLE NODE (CAR N))
               (RETURN NIL))
           ---))
        (ELSE NIL)))

(DEFINE (ALIAS-IF-SAFE-METHOD-2 NODE NODELIST)
  (OR (CONSTANT-NODE? NODE)
      (D0 ((N NODELIST (CDR N)))
          ((NULL? N) T)
        ----
        (IF (NOT (OR (CONSTANT-NODE? (CAR N))
                     (AND (VARIABLE-NODE? (CAR N))
                          (NOT (GETSPARETN (CAR N) 'ENVREF)))
                     (AND (STATIC-NODE? (CAR N))
                          *TARGET-INDIRECTION?*)))
            (RETURN NIL))
        ---)))

;;; Perform type conversion.

(DEFINE (CONVERT-REP NODE SOURCEREP SOURCE DESTREP DEST ALIASP)
  (COND ((EQ? DESTREP SOURCEREP)
         (BUG "not supposed to call CONVERT-REP with equal reps (rep=~S dest=~S source=~S)"
              "will just ignore the operation"
              DESTREP DEST SOURCE)
         DEST)
        ((EQ? DESTREP 'NONE) '(BAD-OPERAND CONVERT-REP))
        (ELSE
         (LET ((FOO (REP-CONVERTER SOURCEREP DESTREP)))
           (COND (FOO ((CAR FOO) NODE SOURCE DEST ALIASP))
                 (ELSE
                  (BUG "can't convert rep ~S (at ~S) to rep ~S (at ~S)"
                       "will simply omit code, and assume data arrived at ~S (ha!)"
                       SOURCEREP SOURCE DESTREP DEST DEST)
                  (MAYBE-INCREMENT-STACKNUM DEST)))))))

(DEFINE (SET-REP-CONVERTER FROM TO PROC SPARE)
  (LET* ((L (OR (ASSQ FROM *REP-CONVERTERS*)
                (LET ((L (CONS FROM '())))
                  ;; Assume obscurer ones are defined later.
                  (SETQ *REP-CONVERTERS* (APPEND! *REP-CONVERTERS* (LIST L)))
                  L)))
         (M (OR (ASSQ TO (CDR L))
                (LET ((M (CONS TO '())))
                  ;; Assume obscurer ones are defined later.
                  (SET (CDR L) (APPEND (CDR L) (LIST M)))
                  M))))
    (SET (CDR M) (CONS PROC SPARE))
    PROC))

(DEFINE (REP-CONVERTER FROM TO)
  (LET ((FROM (IF (EQ? FROM 'SWFIX) 'POINTER FROM))
        (TO   (IF (EQ? TO   'SWFIX) 'POINTER TO)))
    (CDR (ASSQ TO (CDR (ASSQ FROM *REP-CONVERTERS*))))))

;;; This should be more clever someday.  In fact, it should really be
;;; unnecessary someday.

(DEFINE (CONVERT-REP-SPARELOC NODE)
  (COND (NODE (TNLOC (OR (GETSPARETN NODE 'CONVERT-REP)
                         (NODE-WANTTN NODE))))
        (ELSE (BUG "no node for getting spare location for rep conversion"
                   "will use value register, which will definitely lose")
              *VAL*)))

;;; Once upon a time we had a bug which wanted us to do this.

(DEFINE (INCREMENT-STACKNUM) (INCR *STACKNUM*))

(DEFINE (CHECK-NUMBER-OF-CALL-ARGS NODE LOW HIGH)
  (IF (NOT (CALL-NODE? NODE))
      (BUGLET ((*NODE* NODE))
              "request to check number of arguments for a non-CALL node"
              "I don't care, but there's something very fishy here!")
    (LET ((N (LENGTH (CALL-ARGS (NODE-FORM NODE)))))
      (IF (OR (FX< N LOW) (FX> N HIGH))
          (BUGLET ((*NODE* NODE))
                  "number of arguments ~D for ~S isn't in the range [~D,~D]"
                  "I don't know what to do (this should have been checked earlier)"
                  N
                  (SEXPRFY (CALL-FUNCTION (NODE-FORM NODE)))
                  LOW
                  HIGH)))))

;;; Return an operand for the WANTTN of a node.

(DEFINE (WANTTNLOC NODE)
  (TNLOC (NODE-WANTTN (NODE-LEVEL NODE))))

;;; Return an operand for the ISTN of a node.

(DEFINE (ISTNLOC NODE)
  (TNLOC (NODE-ISTN NODE)))

(DEFINE (EMPTY-GENERATE-QUEUE)
  (DECLARE (SPECIAL *GENERATE-QUEUE*))
  (FLUSH-QUEUE *GENERATE-QUEUE*))

;;; Processing one item may cause new ones to appear.

(DEFINE (FLUSH-QUEUE QUEUE)
  (DO () ((QUEUE-EMPTY? QUEUE))
    (LET ((ITEM (DEQUEUE QUEUE)))
      (IF (PAIR? ITEM) (BUG)
        (ITEM)))))

;;; This function is a predicate, returning true iff it had to push a 
;;;  word of padding in order to preserve correct alignment (and thus
;;;  if it's necessary to do a pop later!).

(STAT-COUNTER *CALL-FRAME-ADJUSTMENTS*     "calls requiring stack padding")
(STAT-COUNTER *CALL-FRAME-NON-ADJUSTMENTS* "calls not requiring stack padding")

(DEFINE (MAYBE-ALIGN-STACK)
  (DECLARE (FIXNUM *STACKNUM*))
  (COND ((FIXNUM-ODD? *STACKNUM*)
         (EMITREMARK "Fix stack alignment")
         (ZPUSH 1)
         (INCREMENT-STACKNUM)
         (INCR *CALL-FRAME-ADJUSTMENTS*)
         T)
        (ELSE
         (INCR *CALL-FRAME-NON-ADJUSTMENTS*)
         NIL)))

(STAT-COUNTER *CONTINUATION-TEMPLATES* "continuation templates generated")

;;; PUSH-CONT-TEMPLATE: Push the template for a continuation in prepartion
;;;  for either a general procedure call or a CATCH.

(DEFINE (PUSH-CONT-TEMPLATE TTAGS)
  (EMIT-TEMPLATE TTAGS)
  (MOVE-ADDRESS (UNIT-REF (CADR TTAGS)) *PUSH*))


;;; High-level functions: ... GENERATE-CODE, GENERATE

;;; GENERATE-CODE is the top-level entry to the code generator from the
;;; file transducer.  It must be called on a TPROC-strategy LAMBDA node.
;;; In the TPROC case, it should return something which would be an
;;; appropriate argument to FINISH-ASSEMBLY-FILE.

;;; *GENERATE-QUEUE* is a list of things to do when we're done
;;; compiling the current procedure.

(DEFINE (GENERATE-CODE NODE)
  (GENERATE-LAMBDA-CODE NODE))

;;; ... GENERATE-LAMBDA-CODE

;;; Here we spit out the code for a normal procedure's template.
;;; For now, numeric-valued things are not implemented.
;;; *GENERATE-QUEUE* holds a list of functions (normally QLOZURE's)
;;; to run at any point where doing EMIT's won't interefere with some
;;; code already in progress.  We choose to empty this queue between
;;; PROCEDUREs, instead of at unconditional jumps; it's hard to say
;;; what the best strategy is for maximizing byte offsets over word
;;; offsets, so we do things this way.

;;; Jeez, what a hairy mess.

;(STAT-COUNTER *LAMBDA-FRAME-ADJUSTMENTS* "stack alignments on function entry")

(COMPILATION-GLOBAL *TP-LOC*)           ; Make sure its top-level value is NIL.

(DEFINE *CLOSURE-DEBUG?* T)

(DEFINE (GENERATE-LAMBDA-CODE NODE)
  (SETUP-LAMBDA-TEMPLATE NODE)
  (LET ((FM (NODE-FORM NODE)))
   (BIND ((*GENERATE-NODE* NODE)
          (*GENERATE-QUEUE* (MAKE-QUEUE))
          (*REGION* (LAMBDA-REGION FM)))
     (IF (LAMBDA-NAME FM)
         (EMITREMARK (FORMAT NIL "------ Procedure ~S"
                             (IF (STATIC? (LAMBDA-NAME FM))
                                 (STATIC-IDENTIFIER (LAMBDA-NAME FM))
                               (VARIABLE-IDENTIFIER (LAMBDA-NAME FM)))))
       (EMITCOMMENT "------" NODE))
     (LET ((NARGS (LENGTH (LAMBDA-VARS FM)))
           (LEXPR? (NOT (EMPTY (LAMBDA-RESTVAR FM))))
           (SZ (XCASE (LAMBDA-STRATEGY FM)
                 ((TPROC) 0)
                 ((PROC)
                  (COND ((NULL? (NODE-CONSENV NODE)) 0) ; same as TPROC case
                        ((EQ? NODE (CAR (NODE-CONSENV NODE)))
                         (LENGTH (CDR (NODE-CONSENV NODE))))
                        (ELSE 1)))
                 ((EZCLOSE METHOD HANDLER STACK)
                  ;; This is the wrong place to check this.
                  (IF (NODE-MIGRATIONS NODE)
                      (BUGLET ((*NODE* NODE))
                              "this kind of LAMBDA shouldn't have migrations"
                              "will ignore the fact and lunge onwards"))
                  0)))
           (POINTER-MEM-SIZE (REGION-POINTER-MEM-SIZE *REGION*))
           (SCRATCH-MEM-SIZE (REGION-SCRATCH-MEM-SIZE *REGION*)))
       (DECLARE (FIXNUM SZ))
       ;; Set up scratch and pointer memory on stack.
       (LET* ((MEM-SIZE (FX+ POINTER-MEM-SIZE SCRATCH-MEM-SIZE))
              (FILL (COND ((AND (LAMBDA-HAS-CALLS FM)
                                (NOT (FIXNUM-ODD? MEM-SIZE)))
                           ;; (INCR *LAMBDA-FRAME-ADJUSTMENTS*)
                           1)
                          (ELSE 0))))
         ;; Begin this code chunk.
         (BEGIN-CHUNK (LAMBDA-GENTAG FM)        ; template tags
                      *TP-LOC*          ; superior ttag or nil
                      (CONS SZ 0)       ; (ptr . scr) or gc-method slot
                      `(,(IF LEXPR? 'LEXPR 'EXPR)       ; type
                        ,NARGS          ; #args
                        ,POINTER-MEM-SIZE       ;ptr-mem-sz
                        ,(FX+ SCRATCH-MEM-SIZE FILL))   ;scr-mem-sz
                      (GET-HANDLER-TAG NODE)    ; handler ptag or nil
                      (GET-DEFINEE NODE))       ; definee tag or nil - fix this!
         ;; Generate call to LEXPR-SETUP, if needed.  It always returns
         ;;  the arglist in *VAL*.
         (IF LEXPR? (GET-REST-ARG NARGS (LAMBDA-RESTVAR FM)))
         (BIND ((*FRAME-SIZE* (FX+ FILL MEM-SIZE))
                (*STACKNUM* 0)
                (*TP-LOC* (CADR (LAMBDA-GENTAG FM))))
           (ZPUSH (FX- *FRAME-SIZE* NARGS))
           (COND ((AND LEXPR? (LAMBDA-RESTVAR FM))
                  (VARIABLES-COMMENT "Procedure rest-arg"
                                     (LIST (LAMBDA-RESTVAR FM)))
                  (MOVE *VAL* (TNLOC (VARIABLE-TN (LAMBDA-RESTVAR FM))))))
           (VARIABLES-COMMENT "Procedure arguments" (LAMBDA-VARS FM))
           (WALK (LAMBDA (ARGTN V)
                   (IF V (TN-MOVE (VARIABLE-TN V)
                                  (VARIABLE-REP V)
                                  'POINTER
                                  (TNLOC ARGTN)
                                  NIL)))
                 (LAMBDA-ARGTNS FM)
                 (LAMBDA-VARS FM))
           (GENERATE-LAMBDA-ENV-SETUP NODE)
           ;; Can it really be time... to generate code?
           (GENERATE (LAMBDA-BODY FM) NIL)      ;second arg should be irrelevant
           (NEWLINE *ASSEMBLY-OUTPUT*)
           (FLUSH-QUEUE *GENERATE-QUEUE*)
           (SHOVECOMMENT NIL)
           ;; The value returned here gets passed through to
           ;;  FINISH-ASSEMBLY-FILE.  (?)
           (BIND ((*PRINT-LENGTH* 4))
             (FORMAT *NOISE-OUTPUT* "~&;~S compiled~%"
                     (LET ((N (LAMBDA-NAME (NODE-FORM NODE))))
                       (COND ((NULL? N)
                              (MAKE-PRINTABLE-STRUCTURE (SEXPRFY1 NODE 1) 2))
                             ((STATIC? N) (STATIC-IDENTIFIER N))
                             (ELSE (VARIABLE-IDENTIFIER N))
                             ))))
           (CDDR (LAMBDA-GENTAG FM))))))))

;;; Get pointer to procedure that was called.  Then extract our environment out
;;;  of it.

(DEFINE (GENERATE-LAMBDA-ENV-SETUP NODE)
  (LET ((ETN (GETSPARETN NODE 'BODY-ETN)))
    (COND (ETN
           (LET ((FNLOC (TNLOC (GETSPARETN NODE 'FTN))))
             (MOVE (GET-CLOSURE-ENV NODE FNLOC)
                   (TNLOC ETN)))))))

;;; Get the consed environment out of a closure.  FNLOC is a location holding
;;; the closure, and NODE is a node for the closure.

(DEFINE (GET-CLOSURE-ENV NODE FNLOC)
  (LET ((FM (NODE-FORM NODE)))
    (XCASE (LAMBDA-STRATEGY FM)
      ((PROC)
       (IF (EQ? NODE (CAR (NODE-CONSENV NODE)))
           FNLOC
         (INDIRECT FNLOC *FUN*)))       ; incredible kludge
      ((HANDLER)
       ;; In this case, FNLOC holds the entity itself, not the handler.
       ;; If the MAKE-ENTITY call is really ENTITY strategy, then 0th arg =
       ;; entity = 0th arg to MAKE-ENTITY = closure.
       ;; Otherwise 0th arg = bogus-entity, whose PROCEDURE slot = closure.
       (LET ((ENODE (NODE-PARENT (NODE-LEVEL NODE))))
         (GET-CLOSURE-ENV (CAR (CALL-ARGS (NODE-FORM ENODE)))
                          (IF (EQ? (CALL-STRATEGY (NODE-FORM ENODE)) 'ENTITY)
                              FNLOC
                            (SIMPLEREF FNLOC
                                       '%%BOGUS-ENTITY-PROCEDURE-OFFSET
                                       *FUN*)))))
      ((METHOD)
       ;; In this case, FNLOC holds the entity itself, not the method.
       (LET ((HANDLR (NODE-PARENT (NODE-LEVEL NODE))))
         (IF (EQ? (LAMBDA-STRATEGY (NODE-FORM HANDLR)) 'HANDLER)
             (GET-CLOSURE-ENV HANDLR FNLOC)
           ;; We're gonna lose big on the 68000!
           (GET-CLOSURE-ENV HANDLR
                            (SIMPLEREF FNLOC
                                       '%%BOGUS-ENTITY-HANDLER-OFFSET
                                       *FUN*)))))       ; incredible kludge
      ((EZCLOSE STACK) FNLOC)
      )))

(DEFINE (GET-HANDLER-TAG NODE)
  (LET ((ENODE (NODE-PARENT NODE)))     ; (NODE-PARENT ...)  ??
    (COND ((AND ENODE
                (CALL-NODE? ENODE)
                (EQ? (CALL-STRATEGY (NODE-FORM ENODE)) 'ENTITY))
           (LET ((H (CADR (CALL-ARGS (NODE-FORM ENODE)))))
             (IF (NOT (LAMBDA-NODE? H))
                 (BUGLET ((*NODE* NODE))
                         "an entity-strategy call has non-LAMBDA handler"
                         "I don't know!  This is ridiculous!"))
             (IF (NEQ? NODE H)
                 (CDDR (LAMBDA-GENTAG (NODE-FORM H)))
               NIL)))
          (ELSE NIL))))

(DEFINE (GET-DEFINEE NODE)
  (LET ((VAR (LAMBDA-NAME (NODE-FORM NODE))))
    (COND ((AND VAR (STATIC? VAR))
           (UNIT-STATIC-TAG VAR NIL))
          (ELSE
           (LET ((VAR (GET-DEFINEE-VAR NODE)))
             (IF VAR (UNIT-STATIC-TAG VAR NIL) NIL))))))

(DEFINE (GET-DEFINEE-VAR NODE)
  (COND ((EMPTY (NODE-LEVEL NODE)) NIL)
        (ELSE
         (LET ((P (NODE-PARENT (NODE-LEVEL NODE))))
           (COND ((NULL? P) NIL)
                 ;((AND (ENTITY-NODE? P)  ; obsolete
                  ;     (EQ? (NODE-LEVEL NODE)
                  ;         (CAR (CALL-ARGS (NODE-FORM P)))))
                  ;(GET-DEFINEE-VAR P))
                 ((AND (SETQ-NODE? P)
                       (SETQ-DEFINITIONP (NODE-FORM P)))
                  ;; Gross hack for now
                  (SETQ-VAR (NODE-FORM P)))
                 (ELSE NIL))))))

;;; Use this for setting the GENTAG of a PROC or TPROC strategy LAMBDA.
;;; Returns a TTAGS list of the canonical form.
;;; *** We kludge here!  The GENTAG slot is actually a list
;;; ***  (chunktag templatetag [. tproctag]).

(DEFINE (SETUP-LAMBDA-TEMPLATE NODE)
  (LET ((FM (NODE-FORM NODE)))
    (COND ((EMPTY (LAMBDA-GENTAG FM))
           (LET ((VAR (GET-DEFINEE-VAR NODE))
                 (NEEDS-PTAG? (OR (MEMQ (LAMBDA-STRATEGY FM)
                                        '(TPROC METHOD HANDLER))
                                  (NULL? (NODE-CONSENV NODE)))))
             (SETF (LAMBDA-GENTAG FM)
                   (COND (VAR
                          (LET ((ID (STATIC-IDENTIFIER VAR)))
                            (CONS* (MAKE-SPECIAL-TAG 'C ID)
                                   (MAKE-SPECIAL-TAG 'T ID)
                                   (COND (NEEDS-PTAG?
                                          (MAKE-SPECIAL-TAG 'P ID))
                                         (ELSE NIL)))))
                         (ELSE
                          (CONS* (GENTAG 'CHUNK)
                                 (GENTAG 'TEM)
                                 (COND ((NOT NEEDS-PTAG?) NIL)
                                       ((EQ? NODE *FILE-TOPLEVEL-LAMBDA-NODE*)
                                        *THE-ENTRY-TAG*)
                                       (ELSE (GENTAG 'PROC))))))))
           (EMITREMARK "Procedure template")
           (EMIT-TEMPLATE (LAMBDA-GENTAG FM))))
    (LAMBDA-GENTAG FM)))

;;; GENERATE-VERBOSELY: a handy utility, e.g. for WALK's.
;;; There has to be a better way to do this.

(DEFINE (GENERATE-VERBOSELY A)
  (COND ((MEMQ (STYPE (NODE-FORM A)) '(VARIABLE STATIC CONSTANT))
         (EMITCOMMENT NIL A)))
  (GENERATE A T))


;;;; GENERATE

;;; The value of GENERATE is a valid operand which can be
;;; used to access the result value.

(DEFINE (GENERATE NODE FALL-THROUGH?)
  (IF (NODE-MIGRATIONS NODE)
      (GENERATE-MIGRATIONS NODE))
  (LET ((DEST (NODE-DISPATCH GENERATE NODE FALL-THROUGH?)))
    (COND ((NOT (EMPTY (NODE-GENTAG NODE)))
           (EMITTAG (NODE-GENTAG NODE))
           (SETQ *STACKNUM* (NODE-STACKNUM NODE))
           (IF (NODE-WANTTN NODE)
               (WANTTNLOC NODE)
             '(BAD-OPERAND GENERATE)))
          (ELSE DEST))))

(DEFINE (GENERATE-MIGRATIONS NODE)
  (IF *CLOSURE-DEBUG?*
      (FORMAT *NOISE-OUTPUT* "~&;  Consed environment = ~S~%"
              (DEBUG-CONSENV (NODE-CONSENV NODE))))
  (LET ((TTAGS
         (COND ((CAR (NODE-CONSENV NODE))
                (SETUP-LAMBDA-TEMPLATE (CAR (NODE-CONSENV NODE))))
               (ELSE
                (LET ((TTAGS (LIST (GENTAG 'MIGC) (GENTAG 'MIGT)))
                      (SZ (LENGTH (CDR (NODE-CONSENV NODE)))))
                  (EMIT-TEMPLATE TTAGS)
                  (ENQUEUE *GENERATE-QUEUE*
                           (QLOZURE (TTAGS SZ)
                             (LAMBDA ()
                               (BEGIN-CHUNK TTAGS
                                            NIL ; superior ttag or nil - fix!
                                            (CONS SZ 0) ; (ptr . scr)
                                            NIL ; type
                                            NIL ; handler ptag or nil
                                            NIL)        ; definee tag or nil
                               (GEN-INAPPLICABLE))))
                  TTAGS))))
        (CONSLOC (TNLOC (GETSPARETN NODE 'ENVCONS))))
    (GEN-MAKE-EXTEND-FOO (CADR TTAGS)
                         (FX/ (FX+ (LENGTH (NODE-CONSENV NODE)) 1) 2)
                         CONSLOC)
    ;; Copy referenced variables into this contour.
    (DO ((V (CDR (NODE-CONSENV NODE)) (CDR V))
         (I 0 (FX+ I *POINTER*)))
        ((NULL? V)
         (MOVE CONSLOC (TNLOC (NODE-ETN NODE))))
      ----
      ;; Variable may not yet exist, e.g. in the case of a LABELS.
      (COND ((OR (PAIR? (CAR V))
                 (EMPTY (NODE-DEPTH (VARIABLE-BINDER (CAR V))))
                 (FX< (NODE-DEPTH (VARIABLE-BINDER (CAR V)))
                      (NODE-DEPTH NODE)))
             (IF (NOT (PAIR? (CAR V)))
                 (EMITREMARK (FORMAT NIL "Migrate ~S"
                                     (VARIABLE-IDENTIFIER (CAR V)))))
             (MOVE (TNLOC (COND ((PAIR? (CAR V)) (GETSPARETN NODE 'PARENT-ETN))
                                (ELSE (VARIABLE-TN (CAR V)))))
                   (SREF CONSLOC I))))
      ---)))

(DEFINE (DEBUG-CONSENV X)
  (COND ((PAIR? X)
         (MAP DEBUG-CONSENV (CDR X)))
        ((EQ? (STYPE X) 'VARIABLE)
         (VARIABLE-IDENTIFIER X))
        (ELSE '?)))

(DEFDISPATCH GENERATE CONSTANT (NODE FM FALL-THROUGH?)
  (YIELD NODE
         (COND ((EQ? (NODE-WANTREP (NODE-LEVEL NODE)) 'NONE)
                '(BAD-OPERAND CONSTANT))
               (ELSE (CONSTANTLOC (CONSTANT-VALUE FM) (NODE-ISREP NODE))))
         FALL-THROUGH?))

(DEFDISPATCH GENERATE STATIC (NODE FM FALL-THROUGH?)
  (YIELD NODE
         (COND ((EQ? (NODE-WANTREP (NODE-LEVEL NODE)) 'NONE)
                '(BAD-OPERAND VARIABLE))
               (ELSE (VARLOC FM 'REF NODE)))
         FALL-THROUGH?))

(DEFDISPATCH GENERATE VARIABLE (NODE FM FALL-THROUGH?)
  (YIELD NODE
         (COND ((EQ? (NODE-WANTREP (NODE-LEVEL NODE)) 'NONE)
                '(BAD-OPERAND VARIABLE))
               (ELSE (VARLOC FM 'REF NODE)))
         FALL-THROUGH?))

;;; Hack this at some point to do funny vcell stuff if DEFINITIONP.

(DEFDISPATCH GENERATE SETQ (NODE FM FALL-THROUGH?)
  ;; First, an incredible hack to force the generated code for
  ;;  the body to clobber the variable directly, even though the
  ;;  register allocator tries scrupulously to avoid clobberage.
  (COND ((AND (NODE-ALIASP NODE)
              (NULL? (NODE-WANTTN (NODE-LEVEL NODE)))
              (NOT (STATIC? (SETQ-VAR FM))))
         (LET ((NEWTARGET (VARIABLE-TN (SETQ-VAR FM))))
           (IF (EQ? (NODE-WANTTN (SETQ-BODY FM))
                   (NODE-ISTN (SETQ-BODY FM)))
               (SETF (NODE-ISTN (SETQ-BODY FM)) NEWTARGET))
           (SETF (NODE-WANTTN (SETQ-BODY FM)) NEWTARGET))))
  ;; Next, generate code for the body.
  (LET ((LOC (GENERATE (SETQ-BODY FM) T))
        (DEST (VARLOC (SETQ-VAR FM)
                      (COND ((SETQ-DEFINITIONP FM) 'DEF)
                            ((SETQ-LOCALP FM) 'LSET)
                            (ELSE 'SETQ))
                      NODE)))
    (EMITCOMMENT NIL NODE)
    ;; Now get it there.
    (MOVE LOC DEST)
    (YIELD NODE LOC FALL-THROUGH?)))

;;; Return an operand which references lexical or special value
;;; of a variable.  REFTYPE is for cross-reference purposes only; should
;;; be one of REF, FNREF, SETQ, or DEF.  This will be redone anyhow at some
;;; point... see SYSGEN, and watch this space for news.
;;; Cf. SETUP-STATIC-REF-TN.

(DEFINE (VARLOC VAR REFTYPE NODE)
  (COND ((NULL? VAR)
         '(BAD-OPERAND VARLOC))
        ((STATIC? VAR)
         (INDIRECT (STATIC-LOC VAR REFTYPE)
                   (IF *TARGET-INDIRECTION?*
                       NIL
                     (TNLOC (GETSPARETN NODE 'STATIC-REF)))))
        ((AND (VARIABLE-KNOWN-FUNCTION VAR)
              (EQ? (LAMBDA-STRATEGY (NODE-FORM (VARIABLE-KNOWN-FUNCTION VAR)))
                   'EZCLOSE))
         '(BAD-OPERAND EZCLOSE))
        ((OR (NULL? NODE)
             (NULL? (VARIABLE-CLOSURE-REFS VAR))
             (AND (NULL? (VARIABLE-WRITE-REFS VAR))
                  (EQ? (TN-REGION (VARIABLE-TN VAR)) *REGION*)))
         (TNLOC (VARIABLE-TN VAR)))
        (ELSE
         ;; now CDR the env the right number of times...
         (ENVREF VAR
                 (NODE-CONSENV NODE)
                 (TNLOC (NODE-ETN NODE))
                 (TNLOC (GETSPARETN NODE 'ENVREF))))
        ))

(DEFINE (GEN-STATIC-LOCATIVE STATIC)
  (STATIC-LOC STATIC NIL))

;;; CENV's CAR is ignored by this routine, and should be either nil or a
;;; LAMBDA-node.

(DEFINE (ENVREF THING CENV ENVLOC SPARELOC)
  (COND ((EQ? THING CENV) ENVLOC)
        ((NOT (PAIR? CENV)) (ENVREF-BUG THING))
        ((MEMQ THING (CDR CENV))
         (SIMPLEREF ENVLOC
                    (FX* (POSQ THING (CDR CENV)) *POINTER*)
                    SPARELOC))
        ((PAIR? (CADR CENV))
         (ENVREF THING (CADR CENV) (SIMPLEREF ENVLOC 0 SPARELOC) SPARELOC))
        (ELSE (ENVREF-BUG THING))))

(DEFINE (ENVREF-BUG THING)
  (BUGLET ((*THING* THING))
          "environment lookup lost big - object wasn't there"
          "will use (BAD-OPERAND ENVREF), which won't work very well"))

(DEFDISPATCH GENERATE LAMBDA (NODE FM FALL-THROUGH?)
  (XCASE (LAMBDA-STRATEGY FM)
    ((JUMP)             ;Maybe see GENERATE-CALL-JUMP for elucidation.
     (SETF (LAMBDA-GENTAG (NODE-FORM NODE)) NIL))
    ((EZCLOSE)
     (SETUP-LAMBDA-TEMPLATE NODE)
     (ENQUEUE *GENERATE-QUEUE*
              (QLOZURE (NODE)
                (LAMBDA ()
                  (GENERATE-LAMBDA-CODE NODE)))))
    ((TPROC METHOD HANDLER)
     (GENERATE-TPROC-LAMBDA NODE FALL-THROUGH?))
    ((PROC)
     (COND ((NULL? (NODE-CONSENV NODE))
            (GENERATE-TPROC-LAMBDA NODE FALL-THROUGH?))
           (ELSE
            (GENERATE-PROC-LAMBDA  NODE FALL-THROUGH?))))
    ;((STACK) (GENERATE-STACK-LAMBDA NODE FALL-THROUGH?))
	 ))

(DEFINE (GENERATE-TPROC-LAMBDA NODE FALL-THROUGH?)
  (SETUP-LAMBDA-TEMPLATE NODE)
  (ENQUEUE *GENERATE-QUEUE*
           (QLOZURE (NODE)
             (LAMBDA () (GENERATE-LAMBDA-CODE NODE))))
  (YIELD NODE
         (UNIT-ADDR-REF (CDDR (LAMBDA-GENTAG (NODE-FORM NODE))))
         FALL-THROUGH?))

(DEFINE (GENERATE-PROC-LAMBDA NODE FALL-THROUGH?)
  (SETUP-LAMBDA-TEMPLATE NODE)
  (ENQUEUE *GENERATE-QUEUE*
           (QLOZURE (NODE)
             (LAMBDA () (GENERATE-LAMBDA-CODE NODE))))
  (LET ((FM (NODE-FORM NODE))
        (PLOC (ISTNLOC NODE)))
    (COND ((NEQ? NODE (CAR (NODE-CONSENV NODE)))
           (IF *CLOSURE-DEBUG?*
               (FORMAT *NOISE-OUTPUT* "~&;  Closure~%"))
           (GEN-MAKE-EXTEND-FOO (CADR (LAMBDA-GENTAG FM)) 1 PLOC)
           (MOVE (TNLOC (NODE-ETN NODE)) (SREF PLOC 0))))
    (YIELD NODE PLOC FALL-THROUGH?)))
  
;;; This routine doesn't really exist yet.

(DEFDISPATCH GENERATE CATCH (NODE FM FALL-THROUGH?)
  (XCASE (CATCH-STRATEGY FM)
    ((EXIT) (GENERATE-CATCH-EXIT NODE FM FALL-THROUGH?))
    ((PROC) (GENERATE-CATCH-PROC NODE FM FALL-THROUGH?))
    ((TAIL) (GENERATE-CATCH-TAIL NODE FM FALL-THROUGH?))))

;;; Purely lexical CATCH: no need to do any consing; the throw can be
;;; open-coded as a jump.

(DEFINE (GENERATE-CATCH-EXIT NODE FM FALL-THROUGH?)
  (IGNORE NODE)
  (GENERATE (CATCH-BODY FM) FALL-THROUGH?))

;;; GENERATE-CATCH-PROC - general "consed" CATCH

;;; We assume that the actual stack pointer (which looks like an
;;;  EXTEND whose template is the continuation address, due
;;;  to our clever alignment strategy) is stored in the 0th slot
;;;  of the consed escape function.  See PRIMITIVE-THROW.

(DEFINE (GENERATE-CATCH-PROC NODE FM FALL-THROUGH?)
  (LET ((VAR (CATCH-VAR FM))
        (SPARELOC (TNLOC (GETSPARETN NODE 'CATCH)))
        (TTAGS (LIST (GENTAG 'CCHK) (GENTAG 'CTEM))))
    (MAYBE-ALIGN-STACK)
    ;; Set up variable to point to escape function.
    (GEN-ESCAPE-PROCEDURE SPARELOC)
    (EMITREMARK "Stow continuation")
    (MOVE 'SP (SREF SPARELOC '%%ESCAPE-PROCEDURE-FRAME-OFFSET))
    (EMITREMARK "Push continuation's template")
    (BIND ((*STACKNUM* *STACKNUM*))
      (PUSH-CONT-TEMPLATE TTAGS)
      (MOVE SPARELOC (TNLOC (VARIABLE-TN VAR)))
      (GENERATE (CATCH-BODY FM) NIL))
    (GENERATE-CONTINUATION TTAGS "Catch point")
    (YIELD NODE *VAL* FALL-THROUGH?)))

(DEFINE (GENERATE-CATCH-TAIL NODE FM FALL-THROUGH?)
  (IGNORE FALL-THROUGH?)
  (LET ((VAR (CATCH-VAR FM))
        (SPARELOC (TNLOC (GETSPARETN NODE 'CATCH))))
    ;; Set up variable to point to escape function.
    (EMITREMARK "Stow continuation")
    (GEN-ESCAPE-PROCEDURE SPARELOC)
    (MOVE-ADDRESS (FRAMELOC -2)
                  (SREF SPARELOC '%%ESCAPE-PROCEDURE-FRAME-OFFSET))
    (MOVE SPARELOC (TNLOC (VARIABLE-TN VAR)))
    (GENERATE (CATCH-BODY FM) NIL)))

(DEFINE (GEN-ESCAPE-PROCEDURE DEST)
  (EMITREMARK "Cons escape function for CATCH")
  (GEN-MAKE-EXTEND '(SLINK ESCAPE-PROCEDURE-TEMPLATE)
                   TARGET:%%ESCAPE-PROCEDURE-SIZE
                   DEST))

;;; This needs to be hacked.

(DEFDISPATCH GENERATE LABELS (NODE FM FALL-THROUGH?)
  (WALK (LAMBDA (A V)
          (GENERATE A T)
          (IF (MEMQ V (NODE-MIGRATIONS NODE))
              (MOVE (TNLOC (VARIABLE-TN V))
                    (ENVREF V
                            (NODE-CONSENV NODE)
                            (TNLOC (NODE-ETN A))
                            (TNLOC (GETSPARETN A 'LABEL))))))
        (LABELS-VALS FM)
        (LABELS-VARS FM))
  (VARIABLES-COMMENT "LABELS variables" (LABELS-VARS FM))
  (GENERATE (LABELS-BODY FM) FALL-THROUGH?))

(DEFDISPATCH GENERATE BLOCK (NODE FM FALL-THROUGH?)
  (IGNORE NODE)
  (DO ((A (BLOCK-ARGS FM) (CDR A)))
      ((NULL? (CDR A))
       (GENERATE (CAR A) FALL-THROUGH?))
    ----
    (GENERATE (CAR A) T)
    ---))

(DEFDISPATCH GENERATE IF (NODE FM FALL-THROUGH?)
  (COND ((OR (EQ? (NODE-WANTREP (IF-CON FM)) 'NONE)
             (AND (FX< (NODE-COMPLEXITY (IF-ALT FM))
                       (NODE-COMPLEXITY (IF-CON FM)))
                  (NOT (EQ? (NODE-WANTREP (IF-ALT FM)) 'NONE))
                  (FX< (NODE-COMPLEXITY (IF-ALT FM)) 40.)))       ;random choice
         (GENERATE-IF-WITH-JUMPS NODE (IF-ALT FM) (IF-CON FM) FALL-THROUGH? NIL))
        (ELSE
         (GENERATE-IF-WITH-JUMPS NODE (IF-CON FM) (IF-ALT FM) FALL-THROUGH? T))))

(DEFINE (GENERATE-IF-WITH-JUMPS NODE CON ALT FALL-THROUGH? REVERSEP)
  (LET ((FM (NODE-FORM NODE))
        (JUMPTAG (GENTAG 'ELSE)))
    (GENERATE-PREDICATE (IF-PRED FM) JUMPTAG REVERSEP)
    (BIND ((*STACKNUM* *STACKNUM*))
      (GENERATE CON NIL))
    (EMITTAG JUMPTAG)
    (GENERATE ALT FALL-THROUGH?)))

;;; Generate code for NODE.  The result of a true
;;; outcome should be a jump to JUMPTAG, and the value returned doesn't matter.
;;; If REVERSEP is non-null then the sense of the predicate should be reversed.

(DEFINE (GENERATE-PREDICATE NODE JUMPTAG REVERSEP)
  (LET ((FM (NODE-FORM NODE)))
    (COND ((AND (CALL-NODE? NODE) (EQ? (CALL-STRATEGY FM) 'PRIMOP))
           (LET ((PRIMOP-PREDICATE
                  (CGET (NODE-FORM (CALL-FUNCTION FM)) 'PRIMOP-PREDICATE)))
             (COND (PRIMOP-PREDICATE
                    (APPLY PRIMOP-PREDICATE NODE JUMPTAG REVERSEP
                           (MAP (LAMBDA (A) (GENERATE A T))
                                (CALL-ARGS FM))))
                   (ELSE
                    (GENERATE-STANDARD-PREDICATE NODE JUMPTAG REVERSEP)))))
          (ELSE (GENERATE-STANDARD-PREDICATE NODE JUMPTAG REVERSEP)))))
                  
(DEFINE (GENERATE-STANDARD-PREDICATE NODE JUMPTAG REVERSEP)
  (BRANCHCOMMENT NODE REVERSEP)
  (COMPARE (GENERATE NODE T) '(SLINK NULL) JUMPTAG (NOT REVERSEP)))

(DEFINE (BRANCHCOMMENT NODE REVERSEP)
  (EMITCOMMENT (COND (REVERSEP "Branch unless") (ELSE "Branch if"))
               NODE))

;;; Someday hair this up for table-lookup dispatches.

(DEFDISPATCH GENERATE CASE (NODE FM FALL-THROUGH?)
  (IGNORE FM)
  (GENERATE-CASE-WITH-COMPARISONS NODE FALL-THROUGH?))

(DEFINE (GENERATE-CASE-WITH-COMPARISONS NODE FALL-THROUGH?)
  (LET* ((FM (NODE-FORM NODE))
         (KEYLOC (GENERATE (CASE-KEY FM) T))
         (KEYREP (NODE-WANTREP (CASE-KEY FM))))
    (DO ((C (CASE-CLAUSES FM) (CDR C)))
        ((NULL? C)
         (GENERATE (CASE-ELSE FM) FALL-THROUGH?))
      (DO ((KEYS (CAAR C) (CDR KEYS))
           (TAG NIL))
          ((NULL? (CDR KEYS))
           (BIND ((*STACKNUM* *STACKNUM*))
             (LET ((NEXTTAG (GENTAG 'NEXT)))
               (EMITREMARK (FORMAT NIL "Case ~S" (CAR KEYS)))
               (COMPARE KEYLOC (CONSTANTLOC (CAR KEYS) KEYREP) NEXTTAG T)
               (IF TAG (EMITTAG TAG))
               (GENERATE (CDAR C) NIL)
               (EMITTAG NEXTTAG))))
        (EMITREMARK (FORMAT NIL "Case ~S" (CAR KEYS)))
        (COMPARE KEYLOC
                 (CONSTANTLOC (CAR KEYS) KEYREP)
                 (OR TAG (SETQ TAG (GENTAG 'CASE)))
                 NIL)))))

(DEFDISPATCH GENERATE CALL (NODE FM FALL-THROUGH?)
  (XCASE (CALL-STRATEGY FM)
    ((LET) (GENERATE-CALL-LET NODE FALL-THROUGH?))
    ((JUMP) (GENERATE-CALL-JUMP NODE FALL-THROUGH?))
    ((EXIT) (GENERATE-CALL-EXIT NODE FALL-THROUGH?))
    ((PROC) (GENERATE-CALL-PROCEDURE NODE FALL-THROUGH?))
    ((TAIL) (GENERATE-CALL-TAIL-PROCEDURE NODE FALL-THROUGH?))
    ((ENTITY) (GENERATE-CALL-ENTITY NODE FALL-THROUGH?))
    ((PRIMOP) (GENERATE-CALL-PRIMOP NODE FALL-THROUGH?))))

(DEFINE (GENERATE-CALL-LET NODE FALL-THROUGH?)
  (LET* ((FM (NODE-FORM NODE))
         (FN (NODE-FORM (CALL-FUNCTION FM))))
    (WALK (LAMBDA (A) (GENERATE A T)) (CALL-ARGS FM))
    (VARIABLES-COMMENT "LET variables" (LAMBDA-VARS FN))
    (GENERATE (LAMBDA-BODY FN) FALL-THROUGH?)))

(DEFINE (GENERATE-CALL-JUMP NODE FALL-THROUGH?)
  (LET ((FM (NODE-FORM NODE)))
    (LET* ((FNNODE (VARIABLE-KNOWN-FUNCTION
                    (NODE-FORM (CALL-FUNCTION FM))))
           (FN (NODE-FORM FNNODE)))
      (EMITCOMMENT NIL NODE)
      ;; Assign args in parallel
      ;; Hack as in SETQ: clobber the last argument node.
      ;; NOTE!  THIS DOESN'T ALWAYS WORK!
      ;; This failed while compiling ZEVALUE.
      (comment
      (IF (NOT (NULL? (CALL-ARGS FM)))
          (LET ((A (LAST (CALL-ARGS FM)))
                (V (LAST (LAMBDA-VARS FN))))
            (COND ((TRIVIALLY-COERCIBLE? (NODE-WANTREP A) (VARIABLE-REP V))
                   (LET ((NEWTARGET (VARIABLE-TN V)))
                     (IF (EQ? (NODE-WANTTN A) (NODE-ISTN A))
                         (SETF (NODE-ISTN A) NEWTARGET))
                     (SETF (NODE-WANTTN A) NEWTARGET))))))
      )
      (WALK (LAMBDA (A) (GENERATE A T)) (CALL-ARGS FM))
      (WALK (LAMBDA (A V)
              (IF V
                  (TN-MOVE (VARIABLE-TN V)
                           (VARIABLE-REP V)
                           (NODE-WANTREP A)
                           (WANTTNLOC A)
                           NIL)))
            (CALL-ARGS FM)
            (LAMBDA-VARS FN))
      (COND ((NULL? (LAMBDA-GENTAG FN))
             ;; This incredible hack causes the code for a JUMP-
             ;;  type function to be generated AT the point of
             ;;  one and only one of its "calls", thus ensuring
             ;;  that it actually gets processed, while
             ;;  doing some simple jump-optimization.
             ;; Predicate used to be
             ;;(EQ? (CALL-FUNCTION FM)
             ;;    (CAR (VARIABLE-READ-REFS
             ;;          (NODE-FORM (CALL-FUNCTION FM)))))
             ;; but it's not at all clear that that'll work in general.
             (SETF (LAMBDA-GENTAG FN) (GENTAG 'JUMP))
             (VARIABLES-COMMENT "JUMP LAMBDA args" (LAMBDA-VARS FN))
             (EMITTAG (LAMBDA-GENTAG FN))
             (GENERATE (LAMBDA-BODY FN) FALL-THROUGH?))
            (ELSE (UNCONDITIONAL-JUMP (LAMBDA-GENTAG FN)))))))

(DEFINE (GENERATE-CALL-EXIT NODE FALL-THROUGH?)
  (IGNORE FALL-THROUGH?)
  (CHECK-NUMBER-OF-CALL-ARGS NODE 1 1)
  (GENERATE (CAR (CALL-ARGS (NODE-FORM NODE))) NIL))  ;?!?

(DEFINE (GEN-POINT-OF-CALL NODE)
  (LET ((FM (NODE-FORM NODE)))
    (COND ((AND (EQ? (STYPE FM) 'VARIABLE)
                (VARIABLE-KNOWN-FUNCTION FM))
           (GEN-DIRECT-CALL
            (LAMBDA-GENTAG (NODE-FORM (VARIABLE-KNOWN-FUNCTION FM)))))
          (ELSE
           (GEN-ICALL NODE))))) ; See PRODUCE

(DEFINE (GEN-CALLEE-ENV-SETUP NODE)
  (LET ((FM (NODE-FORM NODE)))
    (COND ((AND (EQ? (STYPE FM) 'VARIABLE)
                (VARIABLE-KNOWN-FUNCTION FM))
           ;; Set up called procedure's env ptr.
           (LET ((FNNODE (VARIABLE-KNOWN-FUNCTION FM)))
             (COND ((NODE-CONSENV FNNODE)
                    ;(IF (NEQ? (NODE-CONSENV FNNODE) (NODE-CONSENV NODE))
                        ;(BUG "don't know how to adjust EZCLOSE consed env"
                         ;    "generate incorrect code"))
                    (MOVE (ENVREF (NODE-CONSENV FNNODE)
                                  (NODE-CONSENV NODE)
                                  (TNLOC (NODE-ETN NODE))
                                  (TNLOC (GETSPARETN NODE 'ENVREF)))
                          *CALLEE-FUN*))))))))

(DEFINE (GENERATE-CALL-PROCEDURE NODE FALL-THROUGH?)
  (LET ((FM (NODE-FORM NODE)))
    (LET ((FNNODE (CALL-FUNCTION FM))
          (TTAGS (LIST (GENTAG 'RCHK) (GENTAG 'RTEM))))
      (MAYBE-ALIGN-STACK)
      ;(WALK (LAMBDA (A)
      ;        (IF (AND (LAMBDA-NODE? A)
      ;                 (EQ? (LAMBDA-STRATEGY (NODE-FORM A)) 'STACK))
      ;            (PUSH-STACK-LAMBDA A)))
      ;      (CALL-ARGS FM))
      (LET ((CONT-STACKNUM *STACKNUM*))
        (BIND ((*STACKNUM* *STACKNUM*))
          (EMITCOMMENT "Set up continuation for call to" FNNODE)
          (PUSH-CONT-TEMPLATE TTAGS)
          ;; Generate arguments.  This causes STACKNUM to grow.  
          (WALK GENERATE-VERBOSELY (CALL-ARGS FM))
          (GENERATE-VERBOSELY FNNODE)   ; Function
          (GEN-CALLEE-ENV-SETUP FNNODE)
          ;; Set up AP to account for the number of arguments pushed.
          (LET* ((NARGS (LENGTH (CALL-ARGS FM)))
                 (EXPECTED (FX+ (FX+ CONT-STACKNUM NARGS) 1)))
            (IF (NOT (FX= *STACKNUM* EXPECTED))
                (BUG "*STACKNUM* is wrong after argument generation (was ~S, expected ~S)"
                     "I don't care, but something is definitely fishy here"
                     *STACKNUM* EXPECTED))
            (EMITREMARK (FORMAT NIL "~D argument~P" NARGS NARGS))
            (SETUP-CONTINUATION NARGS))
          (GEN-POINT-OF-CALL FNNODE)))
      ;; The following must be OUTSIDE the binding of *STACKNUM*.
      (GENERATE-CONTINUATION TTAGS "Return point")
      ;; Should put, in the definee slot, this:
      ;(IF (STATIC-NODE? FNNODE)
      ;    (STATIC-VAR-FLINK-TAG (NODE-FORM FNNODE))
      ;  NIL)
      ;; so debugger knows what thing is being called.
      (YIELD NODE *VAL* FALL-THROUGH?))))

;;; General tail-recursive call.

(DEFINE (GENERATE-CALL-TAIL-PROCEDURE NODE FALL-THROUGH?)
  (DECLARE (SPECIAL *GENERATE-NODE*))
  (IGNORE FALL-THROUGH?)
  (LET* ((FM (NODE-FORM NODE))
         (FNNODE (CALL-FUNCTION FM)))
    (BIND ((*STACKNUM* *STACKNUM*))
      ;; Generate arguments.
      (WALK (LAMBDA (A) (GENERATE A T)) (CALL-ARGS FM))
      ;; Generate the function itself.
      (GENERATE-VERBOSELY FNNODE)
      ;; Zap arguments to their proper place: this is the parallel assignment.
      (WALK (LAMBDA (A)
              (TN-MOVE (GETSPARETN A 'ARG)
                       'POINTER
                       (NODE-WANTREP A) ; Should be POINTER also
                       (WANTTNLOC A)
                       NIL))
            (CALL-ARGS FM))
      (GEN-CALLEE-ENV-SETUP FNNODE)
      ;; Flush temp area, unneeded argframe space, etc. from stack.
      ;; The argument to ADJUST-STACK should be a new value to which *STACKNUM*
      ;; is to be set; however, we fake it out by passing a potentially
      ;; negative number.  It doesn't care, and it makes the call to FRAMELOC
      ;; below do the right thing.
      (ADJUST-STACK (FX- (LENGTH (CALL-ARGS FM)) *FRAME-SIZE*))
      ;; Set up AP, if it isn't already.  AP is maintained correctly in
      ;; functions which don't call external functions.
      ;; Compare with GENERATE-LAMBDA-CODE.
      (COND ((LAMBDA-HAS-CALLS (NODE-FORM *GENERATE-NODE*))
             (EMITREMARK "Establish continuation ptr")
             (MOVE-ADDRESS (FRAMELOC -1) 'AP)))
      (GEN-POINT-OF-CALL FNNODE)
      'GONE)))

;;; GENERATE-CONTINUATION emits the code chunk leader for a continuation.
;;; Assumes that *STACKNUM* is set to the value it will have
;;; when the continuation is invoked.
;;; We could use the DEFINEE option to indicate the name of the procedure
;;; being called, couldn't we?

(DEFINE (GENERATE-CONTINUATION TTAGS REMARK)
  (BEGIN-CHUNK TTAGS
               *TP-LOC*                 ; superior ttag or nil
               (CONS (FX- *STACKNUM* 1) 0); (ptr . scr) or gc-method slot
               '(RETURN)                ; ... see above, or nil
               NIL                      ; handler ptag or nil
               NIL)                     ; definee qtag or nil
  (EMITREMARK REMARK)
  ;; Adjust TP.  This is a prime candidate for pessimization.
  (ADJUST-TP (CADR TTAGS) *TP-LOC*))

;;; Generate (MAKE-ENTITY (LAMBDA ...) (LAMBDA ...)).

(DEFINE (GENERATE-CALL-ENTITY NODE FALL-THROUGH?)
  (LET ((FM (NODE-FORM NODE)))
    (LET ((ARG1 (CAR  (CALL-ARGS FM)))
          (ARG2 (CADR (CALL-ARGS FM))))
      (COND ((LAMBDA-NODE? ARG1)
             ;; Important that arg2 get queued for processing before arg1.
             (SETUP-LAMBDA-TEMPLATE ARG2)
             (ENQUEUE *GENERATE-QUEUE*
                      (QLOZURE (ARG2)
                        (LAMBDA ()
                          (GENERATE-LAMBDA-CODE ARG2))))
             (GENERATE ARG1 FALL-THROUGH?))
            (ELSE
             (BUGLET ((*NODE* NODE))
                     "I don't know how to handle this yet!"
                     "will generate no code (!)")
             '(BAD-OPERAND GENERATE-CALL-ENTITY))))))

;;; Generate code for a call to a primop.
;;; This merely dispatches to the appropriate machine-dependent code.

(DEFINE (GENERATE-CALL-PRIMOP NODE FALL-THROUGH?)
  (LET* ((FM (NODE-FORM NODE))
         (P (NODE-FORM (CALL-FUNCTION FM)))
         (FUN (CGET P 'PRIMOP-GENERATE)))
    (LET ((NARGS (CGET P 'PRIMOP-NUMBER-OF-ARGS)))
      (IF NARGS (CHECK-NUMBER-OF-CALL-ARGS NODE (CAR NARGS) (CDR NARGS))))
    (LET* ((L (MAP (LAMBDA (A) (GENERATE A T)) (CALL-ARGS FM)))
           (LL (MAP (LAMBDA (A LOC)
                      (LET ((ARGTN (GETSPARETN A 'ARG)))
                        (COND (ARGTN (MOVE LOC (TNLOC ARGTN)))
                              (ELSE LOC))))
                    (CALL-ARGS FM)
                    L)))
      (COND (FUN (APPLY FUN NODE FALL-THROUGH? LL))
            (ELSE (BUGLET ((*NODE* NODE))
                          "no code generator for the PRIMOP ~S"
                          "I absolutely refuse to generate code I don't know how to generate!"
                          (STATIC-IDENTIFIER P))
                  '(BAD-OPERAND GENERATE-CALL-PRIMOP))))))


;;; A special and marvelous hack for debugging compiler output!

(DEFINE (VARIABLES-COMMENT REMARK VARS)
  (COND ((AND *ENABLE-LAP-COMMENTARY?*
              (ANY (LAMBDA (V)
                     (AND V (VARIABLE-TN V)))
                   VARS))
         (FORMAT *ASSEMBLY-OUTPUT* "~&~C ~A:"
                 (IF *LISP-ASSEMBLY-SYNTAX?*
                     #\SEMICOLON
                     *COMMENT-START-CHARACTER*)
                 REMARK)
         (WALK (LAMBDA (V)
                 (COND ((AND V (VARIABLE-TN V))
                        (FORMAT *ASSEMBLY-OUTPUT* "  ~S = "
                                (VARIABLE-IDENTIFIER V))
                        (EMIT-OPERAND (VARLOC V NIL NIL)))))
               VARS))))
